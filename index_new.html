<!DOCTYPE HTML>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Advanced Path Optimization Engine | Breakthrough in Graph Algorithms</title>
  <link rel="stylesheet" href="styles.css">
  <meta name="description" content="Discover a revolutionary approach to shortest path computation that breaks traditional complexity barriers. Interactive visualizations, PhD-level mathematics, and real-world applications.">
</head>
<body data-page="home">
  <nav>
    <div class="nav-inner">
      <div class="site-title">PathOpt Engine</div>
      <ul>
        <li><a class="active" href="index.html">Home</a></li>
        <li><a href="theory.html">Theory</a></li>
        <li><a href="interactive.html">Live Demo</a></li>
        <li><a href="about.html">Applications</a></li>
      </ul>
    </div>
  </nav>

  <main>
    <section class="hero">
      <div>
        <h1>Breaking Complexity Barriers in Path Optimization</h1>
        <p class="lead">A revolutionary algorithmic approach that achieves <span class="math-inline">O(m \log^{2/3} n)</span> time complexity for shortest path computation on directed graphs‚Äîsurpassing classical methods for sparse networks.</p>
        <div class="cta-group">
          <a class="btn btn-primary" href="theory.html">Explore the Mathematics</a>
          <a class="btn btn-secondary" href="interactive.html">Interactive Visualization</a>
        </div>
      </div>
      <div class="hero-visual">
        <figure class="animated-graph">
          <svg width="100%" height="280" viewBox="0 0 480 280" role="img" aria-label="Algorithm efficiency visualization">
            <defs>
              <linearGradient id="gradPurple" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#8b5cf6" stop-opacity="0.9" />
                <stop offset="100%" stop-color="#6d28d9" stop-opacity="0.4" />
              </linearGradient>
              <linearGradient id="gradCyan" x1="0%" y1="0%" x2="100%" y2="100%">
                <stop offset="0%" stop-color="#06b6d4" stop-opacity="0.9" />
                <stop offset="100%" stop-color="#0891b2" stop-opacity="0.4" />
              </linearGradient>
              <filter id="glow">
                <feGaussianBlur stdDeviation="4" result="coloredBlur"/>
                <feMerge>
                  <feMergeNode in="coloredBlur"/>
                  <feMergeNode in="SourceGraphic"/>
                </feMerge>
              </filter>
            </defs>
            
            <!-- Classical algorithm curve -->
            <path d="M 30,240 Q 120,200 180,140 T 300,60 T 450,30" 
                  fill="none" stroke="url(#gradPurple)" stroke-width="4" 
                  stroke-linecap="round" opacity="0.6" />
            
            <!-- Advanced algorithm curve -->
            <path d="M 30,240 Q 100,210 160,170 T 280,110 T 450,70" 
                  fill="none" stroke="url(#gradCyan)" stroke-width="5" 
                  stroke-linecap="round" filter="url(#glow)">
              <animate attributeName="stroke-dashoffset" from="1000" to="0" dur="2s" repeatCount="indefinite" />
            </path>
            
            <!-- Data points -->
            <circle cx="180" cy="140" r="6" fill="#8b5cf6" opacity="0.8">
              <animate attributeName="r" values="6;8;6" dur="2s" repeatCount="indefinite" />
            </circle>
            <circle cx="300" cy="60" r="6" fill="#8b5cf6" opacity="0.8">
              <animate attributeName="r" values="6;8;6" dur="2.5s" repeatCount="indefinite" />
            </circle>
            
            <circle cx="160" cy="170" r="7" fill="#06b6d4">
              <animate attributeName="r" values="7;10;7" dur="1.8s" repeatCount="indefinite" />
            </circle>
            <circle cx="280" cy="110" r="7" fill="#06b6d4">
              <animate attributeName="r" values="7;10;7" dur="2.2s" repeatCount="indefinite" />
            </circle>
            
            <!-- Labels -->
            <text x="380" y="50" fill="#8b5cf6" font-family="Inter, sans-serif" font-size="14" font-weight="600">
              Classical O(m + n log n)
            </text>
            <text x="360" y="90" fill="#06b6d4" font-family="Inter, sans-serif" font-size="15" font-weight="700">
              Advanced O(m log^(2/3) n)
            </text>
            
            <text x="40" y="260" fill="#b8c5e0" font-family="Inter, sans-serif" font-size="13">
              Graph Size (n)
            </text>
            <text x="15" y="30" fill="#b8c5e0" font-family="Inter, sans-serif" font-size="13" transform="rotate(-90 15,30)">
              Operations
            </text>
          </svg>
          <figcaption>Complexity comparison: Traditional heap-based approach vs. advanced frontier reduction technique</figcaption>
        </figure>
      </div>
    </section>

    <section class="problem-statement">
      <h2>The Challenge We Solve</h2>
      <p class="section-intro">Computing shortest paths in directed graphs is fundamental to modern computing‚Äîfrom network routing to logistics optimization. Traditional approaches hit a complexity barrier at <span class="math-inline">O(m + n \log n)</span>. We present a breakthrough that breaks this barrier for sparse directed graphs.</p>
      
      <div class="challenge-grid">
        <article class="challenge-card">
          <div class="challenge-icon">üåê</div>
          <h3>Network Routing</h3>
          <p>Internet routers must compute optimal paths through massive network topologies in real-time. Every millisecond counts when handling millions of packets per second.</p>
        </article>
        
        <article class="challenge-card">
          <div class="challenge-icon">üöó</div>
          <h3>Traffic Optimization</h3>
          <p>Modern GPS systems and traffic management platforms need to compute optimal routes across city-scale road networks dynamically as conditions change.</p>
        </article>
        
        <article class="challenge-card">
          <div class="challenge-icon">üì¶</div>
          <h3>Supply Chain Logistics</h3>
          <p>Distribution networks with thousands of nodes require efficient path computation to minimize delivery times and costs across complex transportation networks.</p>
        </article>
      </div>
    </section>

    <section class="innovation">
      <h2>Our Innovation: Frontier Reduction</h2>
      <div class="innovation-content">
        <div class="innovation-text">
          <h3>Breaking the Sorting Barrier</h3>
          <p>Classical algorithms maintain a complete ordering of all vertices by distance, requiring <span class="math-inline">\Omega(n \log n)</span> comparisons. Our key insight:</p>
          
          <div class="insight-box">
            <p><strong>Core Principle:</strong> At any stage, only a small subset of "pivot" vertices‚Äîthose rooting large shortest-path trees‚Äîactually require expensive ordering operations.</p>
          </div>
          
          <p>By identifying these pivots through <span class="math-inline">k</span> rounds of Bellman-Ford-style relaxations, we shrink the frontier from <span class="math-inline">|S|</span> vertices to approximately <span class="math-inline">|S|/k</span> pivots, where <span class="math-inline">k = \lfloor \log^{1/3} n \rfloor</span>.</p>
          
          <div class="math-display">
            \text{Pivot reduction: } |P| \leq \frac{|U|}{k} \text{ where } k = \lfloor \log^{1/3} n \rfloor
          </div>
          
          <p>This reduction cascades through <span class="math-inline">O(\log^{1/3} n)</span> recursion levels, yielding the breakthrough complexity.</p>
        </div>
        
        <div class="innovation-diagram">
          <h4>Frontier Reduction Visualization</h4>
          <div class="diagram-container">
            <svg width="100%" height="320" viewBox="0 0 400 320">
              <defs>
                <marker id="arrowhead" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
                  <polygon points="0 0, 10 3.5, 0 7" fill="#8b5cf6" />
                </marker>
              </defs>
              
              <!-- Initial frontier -->
              <g id="initial-frontier">
                <text x="10" y="30" fill="#b8c5e0" font-size="14" font-weight="600">Initial Frontier |S|</text>
                <rect x="10" y="45" width="380" height="60" rx="8" fill="rgba(139, 92, 246, 0.2)" 
                      stroke="#8b5cf6" stroke-width="2" />
                <circle cx="40" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="80" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="120" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="160" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="200" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="240" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="280" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="320" cy="75" r="6" fill="#8b5cf6" />
                <circle cx="360" cy="75" r="6" fill="#8b5cf6" />
              </g>
              
              <!-- Arrow and process -->
              <line x1="200" y1="115" x2="200" y2="155" stroke="#06b6d4" stroke-width="3" 
                    marker-end="url(#arrowhead)" />
              <text x="110" y="140" fill="#06b6d4" font-size="13" font-weight="600">
                k-round relaxation
              </text>
              
              <!-- After relaxation -->
              <g id="after-relaxation">
                <text x="10" y="180" fill="#b8c5e0" font-size="14" font-weight="600">After k Rounds</text>
                <rect x="10" y="195" width="240" height="55" rx="8" fill="rgba(6, 182, 212, 0.15)" 
                      stroke="#0891b2" stroke-width="2" stroke-dasharray="4,4" />
                <text x="20" y="215" fill="#b8c5e0" font-size="12">Settled vertices</text>
                <circle cx="40" cy="230" r="5" fill="#10b981" opacity="0.7" />
                <circle cx="70" cy="230" r="5" fill="#10b981" opacity="0.7" />
                <circle cx="100" cy="230" r="5" fill="#10b981" opacity="0.7" />
                <circle cx="130" cy="230" r="5" fill="#10b981" opacity="0.7" />
                
                <rect x="270" y="195" width="120" height="55" rx="8" fill="rgba(139, 92, 246, 0.3)" 
                      stroke="#8b5cf6" stroke-width="3" />
                <text x="280" y="215" fill="#f0f4ff" font-size="12" font-weight="700">Pivots |P|</text>
                <circle cx="290" cy="230" r="7" fill="#8b5cf6">
                  <animate attributeName="r" values="7;9;7" dur="1.5s" repeatCount="indefinite" />
                </circle>
                <circle cx="325" cy="230" r="7" fill="#8b5cf6">
                  <animate attributeName="r" values="7;9;7" dur="1.7s" repeatCount="indefinite" />
                </circle>
                <circle cx="360" cy="230" r="7" fill="#8b5cf6">
                  <animate attributeName="r" values="7;9;7" dur="1.9s" repeatCount="indefinite" />
                </circle>
              </g>
              
              <!-- Summary -->
              <text x="10" y="280" fill="#06b6d4" font-size="15" font-weight="600">
                Frontier reduced: |S| = 9 ‚Üí |P| = 3 (factor of 3)
              </text>
              <text x="10" y="305" fill="#b8c5e0" font-size="13">
                Recursion depth: O(log^(1/3) n) levels
              </text>
            </svg>
          </div>
        </div>
      </div>
    </section>

    <section class="key-features">
      <h2>Algorithm Highlights</h2>
      <div class="card-grid">
        <article class="card feature-card">
          <div class="feature-icon">‚ö°</div>
          <h3>Sublinear Sorting Overhead</h3>
          <p>By processing only <span class="math-inline">|U|/\log^{\Omega(1)} n</span> pivots at each recursion level, we reduce per-vertex work from <span class="math-inline">\log n</span> to <span class="math-inline">\log n / \log^{\Omega(1)} n</span>.</p>
          <div class="math-display mini">
            \text{Time per vertex: } \frac{\log n}{\log^{1/3} n} = \log^{2/3} n
          </div>
        </article>
        
        <article class="card feature-card">
          <div class="feature-icon">üîÑ</div>
          <h3>Recursive Partitioning</h3>
          <p>Divide-and-conquer strategy with <span class="math-inline">O(\log^{1/3} n)</span> recursion depth. Each level processes distance-bounded subproblems via a partial-order data structure.</p>
          <div class="complexity-badge">Depth: <span class="math-inline">\lceil \log n / t \rceil</span> where <span class="math-inline">t = \lfloor \log^{2/3} n \rfloor</span></div>
        </article>
        
        <article class="card feature-card">
          <div class="feature-icon">üéØ</div>
          <h3>Pivot Identification</h3>
          <p>After <span class="math-inline">k</span> Bellman-Ford rounds, vertices rooting shortest-path trees of size <span class="math-inline">\geq k</span> are identified as pivots. Remaining vertices are settled without sorting.</p>
          <div class="math-display mini">
            P = \{ u \in S : |\text{Tree}(u)| \geq k \}
          </div>
        </article>
        
        <article class="card feature-card">
          <div class="feature-icon">üìä</div>
          <h3>Partial-Order Structure</h3>
          <p>Custom data structure supporting Insert <span class="math-inline">O(\max\{1, \log(N/M)\})</span>, BatchPrepend <span class="math-inline">O(L \log(L/M))</span>, and Pull <span class="math-inline">O(M)</span> operations.</p>
          <div class="complexity-badge">Block-based linked list + Red-Black tree</div>
        </article>
        
        <article class="card feature-card">
          <div class="feature-icon">‚úì</div>
          <h3>Deterministic Guarantee</h3>
          <p>Unlike randomized approaches, our algorithm provides guaranteed <span class="math-inline">O(m \log^{2/3} n)</span> worst-case performance in the comparison-addition model.</p>
          <div class="complexity-badge">Comparison-addition model</div>
        </article>
        
        <article class="card feature-card">
          <div class="feature-icon">üåç</div>
          <h3>Real-World Impact</h3>
          <p>Asymptotic improvement over classical <span class="math-inline">O(m + n \log n)</span> becomes significant for large sparse graphs (m = O(n)) with <span class="math-inline">n > 10^6</span> vertices.</p>
          <div class="complexity-badge">Sparse graphs: m = O(n)</div>
        </article>
      </div>
    </section>

    <section class="complexity-analysis">
      <h2>Complexity Breakdown</h2>
      <div class="analysis-container">
        <div class="analysis-card">
          <h3>Classical Approach (Dijkstra + Fibonacci Heap)</h3>
          <div class="complexity-formula">
            <span class="math-display">T(n, m) = O(m + n \log n)</span>
          </div>
          <ul class="complexity-details">
            <li><strong>Extract-Min:</strong> <span class="math-inline">n</span> operations √ó <span class="math-inline">O(\log n)</span> = <span class="math-inline">O(n \log n)</span></li>
            <li><strong>Decrease-Key:</strong> <span class="math-inline">m</span> operations √ó <span class="math-inline">O(1)</span> amortized = <span class="math-inline">O(m)</span></li>
            <li><strong>Total:</strong> <span class="math-inline">O(m + n \log n)</span></li>
            <li class="bottleneck">‚ö†Ô∏è Bottleneck: Maintaining total order of <span class="math-inline">\Theta(n)</span> vertices</li>
          </ul>
        </div>
        
        <div class="analysis-card advanced">
          <h3>Advanced Approach (Frontier Reduction)</h3>
          <div class="complexity-formula">
            <span class="math-display">T(n, m) = O(m \log^{2/3} n)</span>
          </div>
          <ul class="complexity-details">
            <li><strong>FindPivots:</strong> <span class="math-inline">k</span> rounds √ó <span class="math-inline">|U|</span> vertices = <span class="math-inline">O(k|U|)</span> per level</li>
            <li><strong>Recursion:</strong> <span class="math-inline">O(\log n / t)</span> levels, each processing <span class="math-inline">O(n)</span> vertices total</li>
            <li><strong>Data structure:</strong> Partial ordering of <span class="math-inline">O(|U|/k)</span> pivots per level</li>
            <li><strong>Total:</strong> <span class="math-inline">O(nk \cdot \log n / t + m \log^{2/3} n)</span> = <span class="math-inline">O(m \log^{2/3} n)</span></li>
            <li class="advantage">‚úì Breakthrough: Only <span class="math-inline">|U|/\log^{1/3} n</span> vertices need ordering</li>
          </ul>
        </div>
      </div>
      
      <div class="comparison-table">
        <h3>Performance Comparison on Sparse Graphs (m = O(n))</h3>
        <table>
          <thead>
            <tr>
              <th>Graph Size (n)</th>
              <th>Classical <span class="math-inline">O(n \log n)</span></th>
              <th>Advanced <span class="math-inline">O(n \log^{2/3} n)</span></th>
              <th>Speedup Factor</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>1,000</td>
              <td>9,966</td>
              <td>9,950</td>
              <td>1.00√ó</td>
            </tr>
            <tr>
              <td>10,000</td>
              <td>132,877</td>
              <td>92,832</td>
              <td>1.43√ó</td>
            </tr>
            <tr>
              <td>100,000</td>
              <td>1,660,964</td>
              <td>857,343</td>
              <td>1.94√ó</td>
            </tr>
            <tr class="highlight">
              <td>1,000,000</td>
              <td>19,931,569</td>
              <td>7,778,012</td>
              <td><strong>2.56√ó</strong></td>
            </tr>
            <tr class="highlight">
              <td>10,000,000</td>
              <td>232,534,967</td>
              <td>69,220,157</td>
              <td><strong>3.36√ó</strong></td>
            </tr>
          </tbody>
        </table>
        <p class="table-note">Note: Operation counts are illustrative based on theoretical complexity. Actual performance depends on implementation details and constant factors.</p>
      </div>
    </section>

    <section class="cta-section">
      <div class="cta-card">
        <h2>Experience the Algorithm in Action</h2>
        <p>Explore interactive visualizations showing step-by-step execution, frontier reduction, pivot selection, and complexity analysis on customizable graph examples.</p>
        <div class="cta-buttons">
          <a href="interactive.html" class="btn btn-large">Launch Interactive Demo</a>
          <a href="theory.html" class="btn btn-secondary">Read Full Theory</a>
        </div>
      </div>
    </section>
  </main>

  <footer>
    <div class="footer-content">
      <p>Educational visualization platform for advanced graph algorithms</p>
      <p class="footer-note">This site presents theoretical computer science research on shortest path algorithms. All mathematical content is educational in nature.</p>
    </div>
  </footer>

  <script src="script.js"></script>
</body>
</html>
