<!DOCTYPE html>
      <!-- STEP-THROUGH EXAMPLES -->
      <section id="running-examples" class="card">
        <h2>ğŸ”¬ Step-through Examples</h2>
        <p>Explore animated examples in the <a href="interactive.html">Interactive Lab</a>. They show k-round relaxations, pivot selection, and recursion on toy graphs. These are illustrative for understanding; performance claims should be taken from the paper.</p>
      </section>
  
  if |W| > k|S| then
    return (B, W)  <span style="color:#9fb3d1">// Too much work; partial execution</span>
  
  <span style="color:#6bffbf">// Phase 2: Recursion on pivots</span>
  U â† W
  Q â† priority queue with pivots P, sorted by dist[]
  
  while Q not empty do
    <span style="color:#9fb3d1">// Extract small batch of closest pivots</span>
    S' â† Pull(Q, min(2<sup>(â„“-1)t</sup>, |Q|))
    b' â† min dist[x] for x in S'
    
    if â„“ = 0 then
      <span style="color:#9fb3d1">// Base case: run mini-Dijkstra</span>
      MiniDijkstra(b', B, S')
      U â† U âˆª {newly completed vertices}
    else
      <span style="color:#9fb3d1">// Recursive case</span>
      (B', U') â† BMSSP(â„“-1, B, S')
      U â† U âˆª U'
      
      if B' < B then
        <span style="color:#9fb3d1">// Partial execution; re-insert incomplete vertices</span>
        BatchPrepend(Q, {v in U' : dist[v] < B'})
      
      if |U| â‰¥ k Â· 2<sup>â„“t</sup> then
        return (min dist[x] for x in U, U)  <span style="color:#9fb3d1">// Workload limit</span>
  
  return (B, U)
        </div>

  <h3>FindPivots Procedure</h3>
    <p>This is the heart of the approach. It identifies which vertices in frontier S root large shortest-path trees.</p>
        
        <div class="code-block">
<strong>FINDPIVOTS</strong>(B, S):
  W â† S  <span style="color:#9fb3d1">// Vertices completed so far</span>
  Wâ‚€ â† S
  
  <span style="color:#6bffbf">// k rounds of batched relaxations (like Bellman-Ford)</span>
  for i = 1 to k do
    Wáµ¢ â† âˆ…
    for all edges (u,v) with u âˆˆ Wáµ¢â‚‹â‚ do
      if dist[u] + w(u,v) < dist[v] then
        dist[v] â† dist[u] + w(u,v)
        pred[v] â† u
        if dist[v] < B then
          Wáµ¢ â† Wáµ¢ âˆª {v}
          W â† W âˆª {v}
    
    if |W| > k|S| then
      return (P=S, W)  <span style="color:#9fb3d1">// Early exit; too many reached</span>
  
  <span style="color:#6bffbf">// Build forest of shortest paths within W</span>
  F â† {(u,v) : u,v âˆˆ W, dist[v] = dist[u] + w(u,v)}
  
  <span style="color:#6bffbf">// Pivots = roots of trees with â‰¥k vertices</span>
  P â† {u âˆˆ S : TreeSize(u, F) â‰¥ k}
  
  return (P, W)
        </div>

  <h3>Visual Example (k=3) â€” illustrative</h3>
        <p>Suppose frontier S = {sâ‚, sâ‚‚, sâ‚ƒ, sâ‚„} and we run 3 rounds of relaxations:</p>
        
        <div class="code-block">
Round 1: sâ‚â†’{vâ‚,vâ‚‚}, sâ‚‚â†’{vâ‚ƒ}, sâ‚ƒâ†’{vâ‚„,vâ‚…,vâ‚†}, sâ‚„â†’{vâ‚‡}
Round 2: vâ‚â†’{vâ‚ˆ,vâ‚‰}, vâ‚„â†’{vâ‚â‚€}, ...
Round 3: vâ‚ˆâ†’{vâ‚â‚}, ...

Forest Analysis:
  Tree(sâ‚): {sâ‚, vâ‚, vâ‚‚, vâ‚ˆ, vâ‚‰, vâ‚â‚} â†’ 6 vertices â‰¥ 3 âœ“ PIVOT
  Tree(sâ‚‚): {sâ‚‚, vâ‚ƒ} â†’ 2 vertices < 3 âœ— not pivot
  Tree(sâ‚ƒ): {sâ‚ƒ, vâ‚„, vâ‚…, vâ‚†, vâ‚â‚€} â†’ 5 vertices â‰¥ 3 âœ“ PIVOT
  Tree(sâ‚„): {sâ‚„, vâ‚‡} â†’ 2 vertices < 3 âœ— not pivot

Result: P = {sâ‚, sâ‚ƒ}, |P| = 2 â‰ª |S| = 4
        </div>

        <p><strong>Key Insight:</strong> Only 2 out of 4 frontier vertices need expensive sorting/recursion. The rest were handled by cheap edge relaxations.</p>

  <h3>Time Complexity (from the paper)</h3>
  <p>With parameters <span class="math-inline">k=\lfloor \log^{1/3} n \rfloor</span> and <span class="math-inline">t=\lfloor \log^{2/3} n \rfloor</span>, the algorithm runs in <span class="math-inline">O(m\,\log^{2/3} n)</span> time in the comparisonâ€“addition model. This combines k-step relaxations (to find pivots), shallow recursion on a reduced frontier, and a partial-order data structure.</p>

        <div class="theorem-box">
          <h4>Theorem (Directed SSSP Complexity)</h4>
          <p>There exists a deterministic algorithm for SSSP on directed graphs with non-negative weights that runs in <span class="math-inline">O(m \log^{2/3} n)</span> time in the comparisonâ€“addition model. For sparse graphs with <span class="math-inline">m=O(n)</span>, this is <span class="math-inline">O(n \log^{2/3} n)</span>.</p>
        </div>
      </section>

      <!-- EXAMPLE WALKTHROUGH -->
      <section id="example" class="card">
        <h2>ğŸ¯ Example: Small Graph (n=8, k=2)</h2>
        
        <h3>Setup</h3>
        <div class="code-block">
Vertices: {s, A, B, C, D, E, F, G}
Source: s
k = âŒŠlog<sup>1/3</sup> 8âŒ‹ = 2
t = âŒŠlog<sup>2/3</sup> 8âŒ‹ = 4
depth = âŒˆlog 8 / 4âŒ‰ = 1

Edges (constant degree 3):
  s â†’ A(1), B(3), C(5)
  A â†’ D(2), E(4)
  B â†’ D(1), F(2)
  C â†’ E(1), G(3)
  D â†’ G(1)
  E â†’ F(1), G(2)
  F â†’ G(1)
        </div>

        <h3>Execution</h3>
        <div class="code-block">
<strong>Level 1: BMSSP(â„“=1, B=âˆ, S={s})</strong>

  FindPivots(âˆ, {s}):
    Round 1: Relax edges from s
      dist[A]=1, dist[B]=3, dist[C]=5
      Wâ‚ = {s, A, B, C}
    
    Round 2: Relax edges from {A,B,C}
      Aâ†’D: dist[D]=3
      Aâ†’E: dist[E]=5
      Bâ†’D: dist[D]=3 (no change)
      Bâ†’F: dist[F]=5
      Câ†’E: dist[E]=5 (no change)
      Wâ‚‚ = {s, A, B, C, D, E, F}
    
    Forest analysis:
      Tree(s): {s, A, B, C, D, E, F} â†’ 7 vertices â‰¥ 2 âœ“
    
    Return: P = {s}, W = {s,A,B,C,D,E,F}
  
  Recursion on P={s}:
    BMSSP(â„“=0, B=âˆ, S'={s}):
      Base case: MiniDijkstra
      Settles remaining vertex G
      dist[G] = min(Dâ†’G: 4, Eâ†’G: 7, Fâ†’G: 6) = 4

<strong>Final distances:</strong>
  s:0, A:1, B:3, C:5, D:3, E:5, F:5, G:4
        </div>

        <h3>Analysis</h3>
        <p><strong>Operations:</strong></p>
        <ul>
          <li>FindPivots: 2 rounds Ã— 8 edges = 16 relaxations</li>
          <li>Recursion: Only 1 pivot (instead of 7 vertices to sort)</li>
          <li>Base case: Mini-Dijkstra on remaining vertex</li>
        </ul>
        
        <p><strong>Dijkstra comparison:</strong> Would need to maintain heap with up to 7 vertices â†’ 7 log 7 â‰ˆ 20 operations. BMSSP-based method used 16 + minimal recursion.</p>
      </section>

      <!-- CORRECTNESS -->
      <section id="correctness" class="card">
        <h2>âœ… Correctness</h2>
        
        <h3>Invariants</h3>
        <ol>
          <li><strong>Optimality:</strong> When BMSSP completes vertex v, dist[v] equals the true shortest path distance d(s,v)</li>
          <li><strong>Progress:</strong> Every incomplete vertex with d(v) < B has its shortest path visiting some complete vertex in the current frontier or in set W</li>
          <li><strong>Termination:</strong> After depth levels, all vertices are complete</li>
        </ol>

        <h3>Key Lemma (FindPivots Guarantee)</h3>
        <div class="theorem-box">
          <p>Let Å¨ = {all vertices v with d(v) < B whose shortest path visits some vertex in S}. After FindPivots(B, S):</p>
          <ol>
            <li>|W| = O(min{k|S|, |Å¨|})</li>
            <li>|P| â‰¤ |W|/k</li>
            <li>For every x âˆˆ Å¨: either x âˆˆ W (complete), or the shortest path to x visits some pivot in P</li>
          </ol>
        </div>

        <h3>Proof Sketch</h3>
        <p><strong>Case 1 (Early Return):</strong> If |W| > k|S|, we return P=S. Every incomplete vertex's shortest path visits some vertex in S=P (satisfies condition 3).</p>
        
        <p><strong>Case 2 (Forest Analysis):</strong> Consider any incomplete vertex x âˆˆ Å¨. Let y âˆˆ S be the first vertex in S on the shortest path to x. If the yâ†’x shortest path has â‰¤k-1 hops, then after k rounds of relaxation, x becomes complete (x âˆˆ W). Otherwise, the tree rooted at y contains â‰¥k vertices, so y âˆˆ P.</p>
        
        <p>Since pivot trees are edge-disjoint and each has â‰¥k vertices: |P|Â·k â‰¤ |W|, giving |P| â‰¤ |W|/k.</p>
      </section>

      <!-- COMPLEXITY DETAILS -->
      <section id="complexity" class="card">
        <h2>âš™ï¸ Time Complexity (clean statement)</h2>
        <p>Let <span class="math-inline">k=\lfloor \log^{1/3} n \rfloor</span> and <span class="math-inline">t=\lfloor \log^{2/3} n \rfloor</span>. Using:</p>
        <ul>
          <li>k rounds of relaxations to identify pivots,</li>
          <li>a partial-order data structure supporting Insert, BatchPrepend, and Pull, and</li>
          <li>recursion over a reduced frontier for <span class="math-inline">O(\log^{1/3} n)</span> levels,</li>
        </ul>
        <p>the total number of comparisons and additions is <span class="math-inline">O(m\,\log^{2/3} n)</span> in sparse directed graphs (after standard constant-degree reduction). For full proofs and constants, see the paper.</p>
      </section>

      <!-- PRACTICAL NOTES -->
      <section id="practical" class="card">
        <h2>ğŸ’¡ Practical Notes</h2>
        <h3>Small graphs vs. asymptotics</h3>
        <p>On tiny graphs, Dijkstraâ€™s simplicity and lower constants often win in practice. The BMSSP-based method is designed for asymptotic improvements on sparse directed graphs.</p>
        <h3>When it helps</h3>
        <ul>
          <li>Graphs are sparse (after constant-degree reduction) and directed.</li>
          <li>You care about provable asymptotic savings in the comparisonâ€“addition model.</li>
          <li>You can afford a more complex implementation (k-round relaxations, partial-order structure).</li>
        </ul>
        <h3>Assumptions</h3>
        <ol>
          <li>Standard constant-degree reduction preserves sparsity and shortest paths.</li>
          <li>Non-negative edge weights.</li>
          <li>Comparisonâ€“addition cost model.</li>
        </ol>
      </section>

    </article>
  </main>

  <footer>
    <p>&copy; 2024 PathOpt Engine. Advanced shortest path algorithms for modern infrastructure.</p>
  </footer>
</body>
</html>
