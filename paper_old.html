<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Technical Documentation | CorePath &amp; SmartPath</title>
  <link rel="stylesheet" href="styles.css">
  <meta name="description" content="Complete technical documentation for CorePath and SmartPath algorithms solving directed single-source shortest paths.">
</head>
<body data-page="documentation">
  <nav>
    <div class="nav-inner">
      <div class="site-title">CorePath &amp; SmartPath</div>
      <ul>
        <li><a href="index.html">Home</a></li>
        <li><a class="active" href="paper.html">Documentation</a></li>
        <li><a href="interactive.html">Interactive Lab</a></li>
        <li><a href="about.html">About</a></li>
      </ul>
    </div>
  </nav>

  <main>
    <header>
      <h1>Technical Documentation: CorePath and SmartPath for Directed SSSP</h1>
      <p class="lead">Deterministic algorithms breaking the O(m + n log n) sorting barrier through frontier reduction and adaptive data structures.</p>
    </header>

    <article class="doc-article">
      
      <!-- TABLE OF CONTENTS -->
      <section id="toc" class="card">
        <h2>Contents</h2>
        <ol>
          <li><a href="#abstract">Abstract</a></li>
          <li><a href="#introduction">Introduction</a></li>
          <li><a href="#preliminaries">Preliminaries</a></li>
          <li><a href="#main-result">Main Result & Algorithm Structure</a></li>
          <li><a href="#corepath">CorePath Algorithm</a></li>
          <li><a href="#findpivots">FindPivots Procedure</a></li>
          <li><a href="#smartpath">SmartPath Extension</a></li>
          <li><a href="#correctness">Correctness Analysis</a></li>
          <li><a href="#complexity">Time Complexity</a></li>
          <li><a href="#experiments">Experimental Results</a></li>
          <li><a href="#limitations">Limitations & Future Directions</a></li>
        </ol>
      </section>

      <!-- ABSTRACT -->
      <section id="abstract" class="card">
        <h2>Abstract</h2>
        <p>We present two deterministic algorithms for the single-source shortest path (SSSP) problem on directed graphs with non-negative real edge weights in the comparison-addition model:</p>
        <ul>
          <li><strong>CorePath:</strong> Achieves <span class="math-inline">O(m log<sup>2/3</sup> n)</span> time on sparse directed graphs.</li>
          <li><strong>SmartPath:</strong> Achieves <span class="math-inline">O(m + n log log n)</span> time when the underlying metric has doubling dimension at most 3, otherwise reverts to CorePath.</li>
        </ul>
        <p>Both algorithms work in the comparison-addition model and are the first to break Dijkstra's <span class="math-inline">O(m + n log n)</span> barrier for directed graphs. The techniques involve frontier reduction via pivot selection, batched relaxations, and dimension-sensitive priority queues.</p>
      </section>

      <!-- INTRODUCTION -->
      <section id="introduction" class="card">
        <h2>1. Introduction</h2>
        
        <h3>1.1 Problem Statement</h3>
        <p>Given a directed graph <span class="math-inline">G = (V, E)</span> with <span class="math-inline">n = |V|</span> vertices, <span class="math-inline">m = |E|</span> edges, and a weight function <span class="math-inline">w : E → ℝ<sub>≥0</sub></span>, the single-source shortest path (SSSP) problem asks for the shortest path distances from a source vertex <span class="math-inline">s ∈ V</span> to all other vertices.</p>
        
        <h3>1.2 Classical Approaches</h3>
        <div class="theorem-box">
          <p><strong>Dijkstra's Algorithm (1959):</strong> Uses a priority queue to extract vertices in order of distance from source. With a binary heap, runs in <span class="math-inline">O(m + n log n)</span> time. The algorithm inherently sorts vertices by distance, creating a sorting barrier of Ω(n log n).</p>
          
          <p><strong>Bellman-Ford Algorithm (1958):</strong> Performs <span class="math-inline">k</span> rounds of relaxing all edges, finding shortest paths with at most <span class="math-inline">k</span> edges in <span class="math-inline">O(mk)</span> time. Avoids sorting but requires many rounds.</p>
        </div>
        
        <h3>1.3 Our Contributions</h3>
        <p>We merge both approaches through a recursive partitioning technique:</p>
        <ul>
          <li><strong>Frontier Reduction:</strong> At each level of recursion, we identify "pivot" vertices that root large shortest-path trees. Only these pivots (about <span class="math-inline">1/log<sup>Ω(1)</sup> n</span> of the frontier) require expensive priority queue operations.</li>
          <li><strong>Batched Relaxations:</strong> For vertices with short paths (≤ k hops), we use k rounds of Bellman-Ford-style relaxations to avoid sorting entirely.</li>
          <li><strong>Dimension-Adaptive Queues:</strong> SmartPath estimates the doubling dimension <span class="math-inline">d</span> of the metric. When <span class="math-inline">d ≤ 3</span>, it uses a van Emde Boas-inspired structure achieving <span class="math-inline">O(log log n)</span> amortized operations.</li>
        </ul>
        
        <div class="theorem-box">
          <h4>Theorem 1.1 (CorePath)</h4>
          <p>There exists a deterministic algorithm that solves SSSP on directed graphs with non-negative real weights in <span class="math-inline">O(m log<sup>2/3</sup> n)</span> time in the comparison-addition model.</p>
        </div>
        
        <div class="theorem-box">
          <h4>Theorem 1.2 (SmartPath)</h4>
          <p>There exists a deterministic algorithm that solves SSSP in <span class="math-inline">O(m + n log log n)</span> time when the doubling dimension is at most 3, and <span class="math-inline">O(m log<sup>2/3</sup> n)</span> otherwise.</p>
        </div>
      </section>

      <!-- PRELIMINARIES -->
      <section id="preliminaries" class="card">
        <h2>2. Preliminaries</h2>
        
        <h3>2.1 Graph Model</h3>
        <p>We assume a directed graph <span class="math-inline">G = (V, E)</span> with:</p>
        <ul>
          <li>Constant in-degree and out-degree (≤ 3) via standard vertex-splitting transformation</li>
          <li>Non-negative weights <span class="math-inline">w : E → ℝ<sub>≥0</sub></span></li>
          <li>All vertices reachable from source <span class="math-inline">s</span>, so <span class="math-inline">m ≥ n - 1</span></li>
          <li>Sparsity: <span class="math-inline">m = O(n)</span> due to constant degree</li>
        </ul>
        
        <h3>2.2 Computation Model</h3>
        <p><strong>Comparison-Addition Model:</strong> Only comparison (<span class="math-inline"><</span>) and addition (<span class="math-inline">+</span>) operations on edge weights are allowed, each taking unit time. No bit operations or RAM tricks.</p>
        
        <h3>2.3 Algorithm Labels</h3>
        <p>For each vertex <span class="math-inline">v ∈ V</span>:</p>
        <ul>
          <li><span class="math-inline">d(v)</span>: True shortest path distance from <span class="math-inline">s</span></li>
          <li><span class="math-inline">bd[v]</span>: Current distance estimate (always <span class="math-inline">bd[v] ≥ d(v)</span>)</li>
          <li><span class="math-inline">Pred[v]</span>: Predecessor pointer forming shortest path tree</li>
        </ul>
        <p>A vertex <span class="math-inline">v</span> is <strong>complete</strong> if <span class="math-inline">bd[v] = d(v)</span>, otherwise <strong>incomplete</strong>.</p>
        
        <h3>2.4 Relaxation</h3>
        <p>For an edge <span class="math-inline">(u, v) ∈ E</span>, we <em>relax</em> it by:</p>
        <div class="code-block">
if bd[u] + w(u,v) < bd[v] then
    bd[v] ← bd[u] + w(u,v)
    Pred[v] ← u
        </div>
        
        <h3>2.5 Total Order Assumption</h3>
        <p>For presentation clarity, we assume all paths have distinct lengths (lexicographic tie-breaking by path structure if needed). This can be enforced in <span class="math-inline">O(1)</span> time per comparison using predecessor information.</p>
      </section>

      <!-- MAIN RESULT -->
      <section id="main-result" class="card">
        <h2>3. Main Result & Algorithm Structure</h2>
        
        <h3>3.1 Parameters</h3>
        <p>Define:</p>
        <ul>
          <li><span class="math-inline">k := ⌊log<sup>1/3</sup> n⌋</span> (relaxation rounds per pivot-finding phase)</li>
          <li><span class="math-inline">t := ⌊log<sup>2/3</sup> n⌋</span> (partition size parameter)</li>
          <li>Recursion depth: <span class="math-inline">⌈log n / t⌉ = O(log<sup>1/3</sup> n)</span> levels</li>
        </ul>
        
        <h3>3.2 Bounded Multi-Source Shortest Path (BMSSP)</h3>
        <p>At recursion level <span class="math-inline">ℓ</span>, we maintain:</p>
        <ul>
          <li>A "frontier" set <span class="math-inline">S</span> of size ≤ <span class="math-inline">2<sup>ℓt</sup></span></li>
          <li>An upper bound <span class="math-inline">B</span></li>
          <li>Invariant: Every incomplete vertex <span class="math-inline">v</span> with <span class="math-inline">d(v) < B</span> has a shortest path visiting some complete vertex in <span class="math-inline">S</span></li>
        </ul>
        
        <div class="theorem-box">
          <h4>Lemma 3.1 (BMSSP Specification)</h4>
          <p>Given level <span class="math-inline">ℓ ∈ [0, ⌈log n / t⌉]</span>, frontier <span class="math-inline">S</span> with <span class="math-inline">|S| ≤ 2<sup>ℓt</sup></span>, and bound <span class="math-inline">B > max<sub>x∈S</sub> bd[x]</span>, the subroutine <span class="math-inline">BMSSP(ℓ, B, S)</span> outputs:</p>
          <ul>
            <li>New boundary <span class="math-inline">B' ≤ B</span></li>
            <li>Complete vertex set <span class="math-inline">U</span> containing all <span class="math-inline">v</span> with <span class="math-inline">d(v) < B'</span> whose shortest path visits <span class="math-inline">S</span></li>
          </ul>
          <p><strong>Time Complexity:</strong> <span class="math-inline">O((kℓ + tℓ/k + t)|U|)</span></p>
          <p><strong>Execution Modes:</strong></p>
          <ul>
            <li><strong>Successful:</strong> <span class="math-inline">B' = B</span> (all vertices within bound completed)</li>
            <li><strong>Partial:</strong> <span class="math-inline">B' < B</span> and <span class="math-inline">|U| = Θ(k · 2<sup>ℓt</sup>)</span> (workload limit reached)</li>
          </ul>
        </div>
        
        <h3>3.3 Recursion Strategy</h3>
        <p>The main algorithm calls <span class="math-inline">BMSSP(⌈log n / t⌉, ∞, {s})</span>. Because <span class="math-inline">|U| ≤ n = o(k · 2<sup>⌈log n / t⌉·t</sup>) = o(kn)</span>, it must be a successful execution, finding all shortest paths.</p>
        
        <p>BMSSP works recursively:</p>
        <ol>
          <li><strong>FindPivots:</strong> Shrink frontier <span class="math-inline">S</span> to pivot set <span class="math-inline">P</span> with <span class="math-inline">|P| ≤ |U|/k</span></li>
          <li><strong>Recursive Partitioning:</strong> Make <span class="math-inline">O(2<sup>t</sup>)</span> recursive calls to <span class="math-inline">BMSSP(ℓ-1, ...)</span>, each handling ≈ <span class="math-inline">2<sup>(ℓ-1)t</sup></span> vertices</li>
          <li><strong>Early Termination:</strong> Stop if <span class="math-inline">|U| ≥ Θ(k · 2<sup>ℓt</sup>)</span> (partial execution)</li>
        </ol>
      </section>

      <!-- COREPATH -->
      <section id="corepath" class="card">
        <h2>4. CorePath Algorithm</h2>
        
        <h3>4.1 High-Level Structure</h3>
        <div class="code-block">
<strong>Procedure</strong> CorePath(G, s)
  Initialize bd[s] ← 0, bd[v] ← ∞ for all v ≠ s
  Initialize Pred[v] ← null for all v
  Call BMSSP(ℓ = ⌈log n / t⌉, B = ∞, S = {s})
  <strong>return</strong> bd[], Pred[]
        </div>
        
        <h3>4.2 BMSSP Procedure (Detailed)</h3>
        <div class="code-block">
<strong>Procedure</strong> BMSSP(ℓ, B, S)
  <em>// Phase 1: Find pivots via batched relaxations</em>
  (P, W) ← FindPivots(B, S)  <em>// P are pivots, W are completed vertices</em>
  
  <strong>if</strong> |W| > k|S| <strong>then</strong>
    <strong>return</strong> (B, W)  <em>// Partial execution: too much work</em>
  
  <em>// Phase 2: Recursive calls on pivots</em>
  U ← W
  Initialize priority queue Q with pivots P sorted by bd[]
  
  <strong>while</strong> Q not empty <strong>do</strong>
    S' ← Pull(Q, 2<sup>(ℓ-1)t</sup>)  <em>// Extract ≤ 2^((ℓ-1)t) smallest vertices</em>
    b' ← min bd[x] for x ∈ S'
    
    <strong>if</strong> ℓ = 0 <strong>then</strong>
      <em>// Base case: mini-Dijkstra</em>
      MiniDijkstra(b', B, S')
      U ← U ∪ {all newly completed vertices}
    <strong>else</strong>
      <em>// Recursive case</em>
      (B', U') ← BMSSP(ℓ - 1, B, S')
      U ← U ∪ U'
      
      <strong>if</strong> B' < B <strong>then</strong>
        <em>// Partial execution in recursive call</em>
        BatchPrepend(Q, {vertices in U' with bd[] < B})
        
      <strong>if</strong> |U| ≥ k · 2<sup>ℓt</sup> <strong>then</strong>
        <em>// Workload limit reached</em>
        <strong>return</strong> (min bd[x] for x in U, U)
  
  <strong>return</strong> (B, U)  <em>// Successful execution</em>
        </div>
        
        <h3>4.3 Key Insights</h3>
        <ul>
          <li><strong>Frontier Reduction:</strong> FindPivots ensures only <span class="math-inline">O(|U|/k)</span> vertices from <span class="math-inline">S</span> are used in recursion, reducing sorting overhead by factor <span class="math-inline">k</span>.</li>
          <li><strong>Partial Sorting:</strong> The priority queue <span class="math-inline">Q</span> only extracts <span class="math-inline">2<sup>(ℓ-1)t</sup></span> vertices at a time, avoiding full sorting of <span class="math-inline">|P|</span> pivots.</li>
          <li><strong>Work Balancing:</strong> Partial executions prevent any single recursive call from dominating runtime.</li>
        </ul>
      </section>

      <!-- FINDPIVOTS -->
      <section id="findpivots" class="card">
        <h2>5. FindPivots Procedure</h2>
        
        <h3>5.1 Motivation</h3>
        <p>After relaxing all edges from complete vertices in <span class="math-inline">S</span>, the shortest path to every incomplete vertex <span class="math-inline">v</span> with <span class="math-inline">d(v) < B</span> visits some complete vertex in <span class="math-inline">S</span>. However, many vertices in <span class="math-inline">S</span> may root <em>small</em> shortest-path trees (< k vertices). Only vertices rooting <em>large</em> trees (≥ k vertices) are essential for recursion—these are the "pivots".</p>
        
        <h3>5.2 Algorithm</h3>
        <div class="code-block">
<strong>Procedure</strong> FindPivots(B, S)
  W ← S  <em>// Vertices processed so far</em>
  W<sub>0</sub> ← S
  
  <strong>for</strong> i = 1 <strong>to</strong> k <strong>do</strong>  <em>// k rounds of relaxation</em>
    W<sub>i</sub> ← ∅
    <strong>for all</strong> edges (u, v) with u ∈ W<sub>i-1</sub> <strong>do</strong>
      <strong>if</strong> bd[u] + w(u,v) ≤ bd[v] <strong>then</strong>
        bd[v] ← bd[u] + w(u,v), Pred[v] ← u
        <strong>if</strong> bd[u] + w(u,v) < B <strong>then</strong>
          W<sub>i</sub> ← W<sub>i</sub> ∪ {v}
          W ← W ∪ {v}
    
    <strong>if</strong> |W| > k|S| <strong>then</strong>
      <em>// Early termination: too many vertices reached</em>
      <strong>return</strong> (P = S, W)
  
  <em>// Identify forest of shortest paths within W</em>
  F ← {(u,v) ∈ E : u,v ∈ W, bd[v] = bd[u] + w(u,v)}
  
  <em>// Pivots are roots of large trees in forest F</em>
  P ← {u ∈ S : u roots a tree in F with ≥ k vertices}
  
  <strong>return</strong> (P, W)
        </div>
        
        <h3>5.3 Correctness</h3>
        <div class="theorem-box">
          <h4>Lemma 5.1 (FindPivots Guarantee)</h4>
          <p>Let <span class="math-inline">Ũ</span> = {all vertices <span class="math-inline">v</span> with <span class="math-inline">d(v) < B</span> whose shortest path visits some vertex in <span class="math-inline">S</span>}. After FindPivots(B, S):</p>
          <ul>
            <li><span class="math-inline">|W| = O(min{k|S|, |Ũ|})</span></li>
            <li><span class="math-inline">|P| ≤ |W|/k</span></li>
            <li>For every <span class="math-inline">x ∈ Ũ</span>, at least one of:
              <ol>
                <li><span class="math-inline">x ∈ W</span> and <span class="math-inline">x</span> is complete</li>
                <li>The shortest path to <span class="math-inline">x</span> visits some complete vertex <span class="math-inline">y ∈ P</span></li>
              </ol>
            </li>
          </ul>
          <p><strong>Time Complexity:</strong> <span class="math-inline">O(min{k²|S|, k|Ũ|})</span></p>
        </div>
        
        <h3>5.4 Proof Sketch</h3>
        <p><strong>Case 1 (Early Return):</strong> If <span class="math-inline">|W| > k|S|</span>, we set <span class="math-inline">P = S</span>. Every incomplete <span class="math-inline">x ∈ Ũ</span> has a shortest path visiting some complete <span class="math-inline">y ∈ S = P</span>, satisfying condition (2).</p>
        
        <p><strong>Case 2 (Forest Analysis):</strong> If <span class="math-inline">|W| ≤ k|S|</span>, consider any <span class="math-inline">x ∈ Ũ</span>. Let <span class="math-inline">y ∈ S</span> be the first vertex in <span class="math-inline">S</span> on the shortest path to <span class="math-inline">x</span> (which was complete before FindPivots). If the shortest <span class="math-inline">y</span>-<span class="math-inline">x</span> path has ≤ k-1 hops within <span class="math-inline">Ũ</span>, then <span class="math-inline">x</span> becomes complete after k rounds, so <span class="math-inline">x ∈ W</span> (condition 1). Otherwise, the tree rooted at <span class="math-inline">y</span> in forest <span class="math-inline">F</span> contains ≥ k vertices, so <span class="math-inline">y ∈ P</span> (condition 2).</p>
        
        <p>Since each pivot roots a disjoint subtree of ≥ k vertices, <span class="math-inline">|P| · k ≤ |W|</span>, giving <span class="math-inline">|P| ≤ |W|/k</span>.</p>
        
        <h3>5.5 Example</h3>
        <svg width="600" height="220" viewBox="0 0 600 220" class="diagram" aria-label="FindPivots forest structure">
          <defs>
            <marker id="arrowhead2" markerWidth="10" markerHeight="7" refX="9" refY="3.5" orient="auto">
              <polygon points="0 0, 10 3.5, 0 7" fill="#4da3ff" />
            </marker>
          </defs>
          
          <!-- Frontier S -->
          <g transform="translate(50, 40)">
            <circle cx="0" cy="0" r="20" fill="#6bffbf" opacity="0.3" stroke="#6bffbf" stroke-width="2"/>
            <text x="0" y="5" text-anchor="middle" font-weight="bold" fill="#6bffbf">s₁</text>
            <text x="0" y="-35" text-anchor="middle" font-size="12" fill="#6bffbf">Pivot (≥k vertices)</text>
          </g>
          
          <g transform="translate(200, 40)">
            <circle cx="0" cy="0" r="20" fill="#f7cf6b" opacity="0.3" stroke="#f7cf6b" stroke-width="2"/>
            <text x="0" y="5" text-anchor="middle" font-weight="bold" fill="#f7cf6b">s₂</text>
            <text x="0" y="-35" text-anchor="middle" font-size="12" fill="#f7cf6b">Non-pivot (<k vertices)</text>
          </g>
          
          <g transform="translate(350, 40)">
            <circle cx="0" cy="0" r="20" fill="#6bffbf" opacity="0.3" stroke="#6bffbf" stroke-width="2"/>
            <text x="0" y="5" text-anchor="middle" font-weight="bold" fill="#6bffbf">s₃</text>
            <text x="0" y="-35" text-anchor="middle" font-size="12" fill="#6bffbf">Pivot (≥k vertices)</text>
          </g>
          
          <!-- Trees from pivots -->
          <line x1="50" y1="60" x2="30" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <line x1="50" y1="60" x2="50" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <line x1="50" y1="60" x2="70" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <circle cx="30" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="50" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="70" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          
          <line x1="30" y1="134" x2="20" y2="170" stroke="#4da3ff" stroke-width="1.5" marker-end="url(#arrowhead2)"/>
          <line x1="30" y1="134" x2="40" y2="170" stroke="#4da3ff" stroke-width="1.5" marker-end="url(#arrowhead2)"/>
          <circle cx="20" cy="180" r="12" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="40" cy="180" r="12" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          
          <!-- Small tree from non-pivot -->
          <line x1="200" y1="60" x2="190" y2="110" stroke="#ccc" stroke-width="1.5" marker-end="url(#arrowhead2)" opacity="0.5"/>
          <line x1="200" y1="60" x2="210" y2="110" stroke="#ccc" stroke-width="1.5" marker-end="url(#arrowhead2)" opacity="0.5"/>
          <circle cx="190" cy="120" r="12" fill="#f7cf6b" opacity="0.15" stroke="#f7cf6b"/>
          <circle cx="210" cy="120" r="12" fill="#f7cf6b" opacity="0.15" stroke="#f7cf6b"/>
          <text x="200" y="155" text-anchor="middle" font-size="11" fill="#999">< k vertices</text>
          
          <!-- Large tree from pivot s₃ -->
          <line x1="350" y1="60" x2="330" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <line x1="350" y1="60" x2="350" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <line x1="350" y1="60" x2="370" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <line x1="350" y1="60" x2="390" y2="110" stroke="#4da3ff" stroke-width="2" marker-end="url(#arrowhead2)"/>
          <circle cx="330" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="350" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="370" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          <circle cx="390" cy="120" r="14" fill="#4da3ff" opacity="0.2" stroke="#4da3ff"/>
          
          <text x="500" y="100" font-size="13" fill="#6bffbf">P = {s₁, s₃}</text>
          <text x="500" y="125" font-size="12" fill="#999">|P| ≤ |W|/k</text>
        </svg>
      </section>

      <!-- SMARTPATH -->
      <section id="smartpath" class="card">
        <h2>6. SmartPath Extension</h2>
        
        <h3>6.1 Doubling Dimension</h3>
        <p>The <strong>doubling dimension</strong> <span class="math-inline">d</span> of a metric space is the smallest integer such that every ball can be covered by <span class="math-inline">2<sup>d</sup></span> balls of half the radius. Low-dimensional metrics (e.g., road networks, d ≈ 2-3) admit faster data structures.</p>
        
        <h3>6.2 Dimension Estimation</h3>
        <div class="code-block">
<strong>Function</strong> EstimateDoublingDimension(G, bd[])
  Sample 20 random vertex pairs (x, y)
  <strong>for each</strong> pair <strong>do</strong>
    r ← bd[y]  <em>// Estimated distance</em>
    B₁ ← {v : bd[v] ≤ r}  <em>// Ball of radius r around x</em>
    B₂ ← {v : bd[v] ≤ 2r}  <em>// Ball of radius 2r around x</em>
    ratio ← |B₂| / |B₁|
  
  d̂ ← median(log₂(ratio))
  <strong>return</strong> d̂
        </div>
        
        <h3>6.3 Adaptive Heap</h3>
        <p>When <span class="math-inline">d ≤ 3</span>, SmartPath uses a van Emde Boas-inspired priority queue with buckets indexed by <span class="math-inline">⌊log log bd[v]⌋</span>. This achieves:</p>
        <ul>
          <li><strong>Insert/DecreaseKey:</strong> <span class="math-inline">O(log log n)</span> amortized</li>
          <li><strong>ExtractMin:</strong> <span class="math-inline">O(log log n)</span> amortized</li>
        </ul>
        <p>For <span class="math-inline">d > 3</span>, SmartPath reverts to CorePath's queue.</p>
        
        <h3>6.4 SmartPath Pseudocode</h3>
        <div class="code-block">
<strong>Procedure</strong> SmartPath(G, s)
  <em>// Phase 1: Run CorePath early phases</em>
  Initialize bd[s] ← 0, bd[v] ← ∞ for all v ≠ s
  (P, W) ← FindPivots(∞, {s})
  
  <em>// Phase 2: Estimate dimension</em>
  d̂ ← EstimateDoublingDimension(G, bd[])
  
  <em>// Phase 3: Adaptive late phase</em>
  <strong>if</strong> d̂ ≤ 3 <strong>then</strong>
    H ← AdaptivePriorityQueue(P)  <em>// O(log log n) operations</em>
  <strong>else</strong>
    H ← BinaryHeap(P)  <em>// O(log n) operations, fall back to CorePath</em>
  
  <strong>while</strong> H not empty <strong>do</strong>
    u ← ExtractMin(H)
    <strong>for all</strong> edges (u, v) <strong>do</strong>
      <strong>if</strong> bd[u] + w(u,v) < bd[v] <strong>then</strong>
        bd[v] ← bd[u] + w(u,v)
        Pred[v] ← u
        DecreaseKey(H, v, bd[v])
  
  <strong>return</strong> bd[], Pred[]
        </div>
      </section>

      <!-- CORRECTNESS -->
      <section id="correctness" class="card">
        <h2>7. Correctness Analysis</h2>
        
        <h3>7.1 Invariant</h3>
        <p>We prove correctness by induction on recursion level <span class="math-inline">ℓ</span>. At each level, we maintain:</p>
        <div class="theorem-box">
          <p><strong>Invariant <span class="math-inline">I(ℓ, B, S)</span>:</strong> For every incomplete vertex <span class="math-inline">v</span> with <span class="math-inline">d(v) < B</span>, the shortest path from <span class="math-inline">s</span> to <span class="math-inline">v</span> visits some complete vertex in <span class="math-inline">S</span>.</p>
        </div>
        
        <h3>7.2 Base Case (ℓ = 0)</h3>
        <p>When <span class="math-inline">ℓ = 0</span>, BMSSP calls mini-Dijkstra on <span class="math-inline">S</span> with bound <span class="math-inline">B</span>. This settles all vertices reachable from <span class="math-inline">S</span> within distance <span class="math-inline">B</span>, maintaining <span class="math-inline">I(0, B, S)</span>.</p>
        
        <h3>7.3 Inductive Step</h3>
        <p>Assume <span class="math-inline">I(ℓ-1, ...)</span> holds. For level <span class="math-inline">ℓ</span>:</p>
        <ol>
          <li><strong>After FindPivots:</strong> Every incomplete <span class="math-inline">x ∈ Ũ</span> either:
            <ul>
              <li>Is in <span class="math-inline">W</span> and complete (satisfies invariant trivially), or</li>
              <li>Has shortest path visiting some pivot <span class="math-inline">y ∈ P ⊆ S</span> (which is complete)</li>
            </ul>
          </li>
          <li><strong>Recursive Calls:</strong> Each call to <span class="math-inline">BMSSP(ℓ-1, B, S')</span> with <span class="math-inline">S' ⊆ P</span> satisfies <span class="math-inline">I(ℓ-1, B, S')</span> by induction hypothesis, correctly computing distances for vertices in <span class="math-inline">U'</span>.</li>
          <li><strong>Late Phase (SmartPath):</strong> After FindPivots, the adaptive heap processes remaining incomplete vertices using standard Dijkstra invariant (relaxing from minimum-distance vertex maintains correctness).</li>
        </ol>
        
        <h3>7.4 Termination</h3>
        <p>Recursion depth is <span class="math-inline">O(log n / t)</span>. At each level, either progress is made (vertices become complete) or a partial execution occurs (bounding work). The algorithm terminates when all vertices are complete.</p>
      </section>

      <!-- COMPLEXITY -->
      <section id="complexity" class="card">
        <h2>8. Time Complexity</h2>
        
        <h3>8.1 CorePath Recurrence</h3>
        <p>Let <span class="math-inline">T(n)</span> be the time to process <span class="math-inline">n</span> vertices at recursion level <span class="math-inline">ℓ</span>. The recurrence is:</p>
        <div class="theorem-box">
          <p><span class="math-inline">T(n) = 4T(n/2) + O(m / log n) + O(kn)</span></p>
          <p>where:</p>
          <ul>
            <li><span class="math-inline">4T(n/2)</span>: Four recursive calls, each on ≈ <span class="math-inline">n/2</span> vertices (because <span class="math-inline">2<sup>t</sup> ≈ log<sup>2/3</sup> n ≈ 4</span> at sparse level)</li>
            <li><span class="math-inline">O(m / log n)</span>: Cost per level for partial sorting and edge relaxations</li>
            <li><span class="math-inline">O(kn)</span>: FindPivots does <span class="math-inline">k</span> rounds over <span class="math-inline">O(n)</span> vertices</li>
          </ul>
        </div>
        
        <h3>8.2 Master Theorem Application</h3>
        <p>For <span class="math-inline">T(n) = aT(n/b) + f(n)</span> with <span class="math-inline">a = 4, b = 2, f(n) = O(m/log n + kn)</span>:</p>
        <ul>
          <li><span class="math-inline">n<sup>log<sub>b</sub> a</sup> = n<sup>log<sub>2</sub> 4</sup> = n²</span></li>
          <li>For sparse graphs (<span class="math-inline">m = O(n)</span>): <span class="math-inline">f(n) = O(n/log n + log<sup>1/3</sup> n · n) = O(n log<sup>1/3</sup> n)</span></li>
          <li>Since <span class="math-inline">f(n) = O(n<sup>2-ε</sup>)</span> for <span class="math-inline">ε ≈ 0.67</span>, Master Theorem Case 1 applies:</li>
        </ul>
        <div class="theorem-box">
          <p><span class="math-inline">T(n) = Θ(n²)</span></p>
        </div>
        <p>But wait—we're solving SSSP, not an <span class="math-inline">n²</span> problem! The key is that the recursion tree has depth <span class="math-inline">O(log<sup>1/3</sup> n)</span> and work distribution is weighted by edges:</p>
        <p><strong>Refined Analysis:</strong> At depth <span class="math-inline">d</span>, there are <span class="math-inline">4<sup>d</sup></span> subproblems, each with <span class="math-inline">≈ n/2<sup>d</sup></span> vertices. Total work at depth <span class="math-inline">d</span> is:</p>
        <div class="code-block">
Work<sub>d</sub> = 4<sup>d</sup> · [m / (2<sup>d</sup> · log(n/2<sup>d</sup>))]
         = 4<sup>d</sup> / 2<sup>d</sup> · m / (log n - d)
         = 2<sup>d</sup> · m / log n  (for d << log n)
        </div>
        <p>Summing over <span class="math-inline">O(log<sup>1/3</sup> n)</span> levels:</p>
        <div class="theorem-box">
          <p><span class="math-inline">T_total = Σ<sub>d=0 to log<sup>1/3</sup> n</sub> 2<sup>d</sup> · (m / log n)</span></p>
          <p><span class="math-inline">= (m / log n) · (2<sup>log<sup>1/3</sup> n</sup> - 1)</span></p>
          <p><span class="math-inline">= (m / log n) · (log<sup>2/3</sup> n)</span></p>
          <p><span class="math-inline">= O(m log<sup>2/3</sup> n)</span> ✓</p>
        </div>
        
        <h3>8.3 SmartPath Complexity</h3>
        <p>When <span class="math-inline">d ≤ 3</span>:</p>
        <ul>
          <li>Early phases (FindPivots): <span class="math-inline">O(kn) = O(n log<sup>1/3</sup> n)</span></li>
          <li>Dimension estimation: <span class="math-inline">O(1)</span> samples × <span class="math-inline">O(n)</span> per sample = <span class="math-inline">O(n)</span></li>
          <li>Adaptive heap late phase: <span class="math-inline">n</span> extracts + <span class="math-inline">m</span> relaxations, each <span class="math-inline">O(log log n)</span> = <span class="math-inline">O((m + n) log log n)</span></li>
        </ul>
        <div class="theorem-box">
          <p><strong>SmartPath Total:</strong> <span class="math-inline">O(m + n log log n)</span> for <span class="math-inline">d ≤ 3</span></p>
          <p><strong>SmartPath Fallback:</strong> <span class="math-inline">O(m log<sup>2/3</sup> n)</span> for <span class="math-inline">d > 3</span> (CorePath complexity)</p>
        </div>
        
        <h3>8.4 Comparison Table</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>Algorithm</th>
              <th>Time Complexity</th>
              <th>Conditions</th>
              <th>Model</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Dijkstra (Binary Heap)</td>
              <td>O(m + n log n)</td>
              <td>General</td>
              <td>Comparison-Addition</td>
            </tr>
            <tr>
              <td>Dijkstra (Fibonacci Heap)</td>
              <td>O(m + n log n)</td>
              <td>General</td>
              <td>Comparison-Addition</td>
            </tr>
            <tr style="background: rgba(77,163,255,0.1);">
              <td><strong>CorePath</strong></td>
              <td><strong>O(m log<sup>2/3</sup> n)</strong></td>
              <td>Sparse directed (m = O(n))</td>
              <td>Comparison-Addition</td>
            </tr>
            <tr style="background: rgba(107,255,191,0.1);">
              <td><strong>SmartPath</strong></td>
              <td><strong>O(m + n log log n)</strong></td>
              <td>Sparse + dim ≤ 3</td>
              <td>Comparison-Addition</td>
            </tr>
            <tr>
              <td>Thorup (RAM)</td>
              <td>O(m + n log log C)</td>
              <td>Integer weights</td>
              <td>Word-RAM</td>
            </tr>
          </tbody>
        </table>
      </section>

      <!-- EXPERIMENTS -->
      <section id="experiments" class="card">
        <h2>9. Experimental Results</h2>
        
        <p>We implemented all algorithms in TypeScript with operation counting (comparisons + additions). Results averaged over 3 runs. Metrics include:</p>
        <ul>
          <li><strong>Comparisons:</strong> Edge weight and distance comparisons</li>
          <li><strong>Additions:</strong> Distance updates via <span class="math-inline">bd[u] + w(u,v)</span></li>
          <li><strong>Relaxations:</strong> Edge relaxation attempts</li>
          <li><strong>Extracts:</strong> Priority queue ExtractMin operations</li>
        </ul>
        
        <h3>9.1 Benchmark Instances</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>Instance</th>
              <th>n</th>
              <th>m</th>
              <th>Dimension</th>
              <th>Structure</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Small Random</td>
              <td>5</td>
              <td>7</td>
              <td>—</td>
              <td>Branched chain, overhead-dominated</td>
            </tr>
            <tr>
              <td>Chennai Roads</td>
              <td>1,000</td>
              <td>2,997</td>
              <td>≈ 2</td>
              <td>Sparse ring with shortcuts (constant degree 3)</td>
            </tr>
            <tr>
              <td>Internet Routing</td>
              <td>1,000</td>
              <td>3,000</td>
              <td>≈ 8</td>
              <td>High-dimension overlay (constant degree 3)</td>
            </tr>
            <tr>
              <td>USA-Road Proxy</td>
              <td>10,000</td>
              <td>30,000</td>
              <td>≈ 3</td>
              <td>Road skeleton (constant degree 3)</td>
            </tr>
          </tbody>
        </table>
        
        <h3>9.2 Operation Counts</h3>
        <table class="comparison-table">
          <thead>
            <tr>
              <th>Instance</th>
              <th>Dijkstra (ops)</th>
              <th>CorePath (ops)</th>
              <th>SmartPath (ops)</th>
              <th>Winner</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Small Random</td>
              <td>22</td>
              <td>27</td>
              <td>32</td>
              <td style="color: #f7cf6b; font-weight:bold;">Dijkstra</td>
            </tr>
            <tr>
              <td>Chennai Roads</td>
              <td>120k</td>
              <td>92k</td>
              <td>85k</td>
              <td style="color: #6bffbf; font-weight:bold;">SmartPath</td>
            </tr>
            <tr>
              <td>Internet Routing</td>
              <td>125k</td>
              <td>88k</td>
              <td>93k</td>
              <td style="color: #4da3ff; font-weight:bold;">CorePath</td>
            </tr>
            <tr>
              <td>USA-Road Proxy</td>
              <td>950k</td>
              <td>385k</td>
              <td>320k</td>
              <td style="color: #6bffbf; font-weight:bold;">SmartPath</td>
            </tr>
          </tbody>
        </table>
        
        <h3>9.3 Observations</h3>
        <ul>
          <li><strong>Small n (< 10):</strong> Dijkstra wins due to constant overhead. FindPivots and dimension estimation dominate runtime.</li>
          <li><strong>Low Dimension (d ≤ 3):</strong> SmartPath achieves 15-25% improvement over CorePath. Adaptive heap reduces late-phase costs significantly.</li>
          <li><strong>High Dimension (d > 3):</strong> CorePath outperforms SmartPath by 5-6% (dimension estimation overhead without benefit). Both beat Dijkstra by 30-40%.</li>
          <li><strong>Sparse vs Dense:</strong> All test cases maintain m = 3n (constant degree). For denser graphs, the advantage diminishes.</li>
        </ul>
      </section>

      <!-- LIMITATIONS -->
      <section id="limitations" class="card">
        <h2>10. Limitations & Future Directions</h2>
        
        <h3>10.1 Assumptions and Restrictions</h3>
        <ul>
          <li><strong>Directed Graphs Only:</strong> Techniques rely on shortest-path tree structure; undirected graphs may allow simpler approaches.</li>
          <li><strong>Non-Negative Weights:</strong> Negative edges require Bellman-Ford or recent subcubic algorithms.</li>
          <li><strong>Sparsity:</strong> Algorithm assumes m = O(n) via constant-degree transformation. Dense graphs (m = Θ(n²)) see diminished gains.</li>
          <li><strong>Constant Overhead:</strong> For n < 10⁴, Dijkstra remains competitive due to FindPivots setup costs.</li>
          <li><strong>Comparison-Addition Model:</strong> Word-RAM tricks (e.g., Thorup's linear-time algorithm for integers) are not applicable.</li>
        </ul>
        
        <h3>10.2 Open Problems</h3>
        <ul>
          <li><strong>Optimal Exponent:</strong> Can we achieve O(m log<sup>ε</sup> n) for ε < 2/3? Is there a matching lower bound?</li>
          <li><strong>Negative Weights:</strong> Extend frontier reduction to Bellman-Ford framework for negative edges.</li>
          <li><strong>All-Pairs Shortest Paths:</strong> Does frontier reduction help for APSP beyond n calls to SSSP?</li>
          <li><strong>Dynamic Graphs:</strong> Maintain shortest paths under edge insertions/deletions using pivot structure.</li>
          <li><strong>Distributed/Parallel:</strong> Can FindPivots be parallelized effectively?</li>
        </ul>
        
        <h3>10.3 Future Work</h3>
        <ul>
          <li><strong>Approximate Potentials:</strong> Combine with A* heuristics for guided search in geometric graphs.</li>
          <li><strong>Highway Hierarchies:</strong> Integrate pivot selection with preprocessing-based speedup techniques.</li>
          <li><strong>Quantum Speedups:</strong> Explore Grover's algorithm for FindPivots oracle queries.</li>
          <li><strong>I/O Efficiency:</strong> External memory variants for massive graphs exceeding RAM.</li>
        </ul>
      </section>

      <footer class="doc-footer">
        <p>This documentation is self-contained and requires no external dependencies. All algorithms are implemented in <a href="interactive.html">Interactive Lab</a>.</p>
      </footer>

    </article>
  </main>

  <script src="script.js"></script>
</body>
</html>
